# -*- coding: utf-8 -*-
"""notebook.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1sRlM79n0OJAWK-8c-E5WLV81dy8jRz1W

----

-----

# ¿Cuál es la mejor tarifa?

Trabajas como analista para el operador de telecomunicaciones Megaline. La empresa ofrece a sus clientes dos tarifas de prepago, Surf y Ultimate. El departamento comercial quiere saber cuál de las tarifas genera más ingresos para poder ajustar el presupuesto de publicidad.

Vas a realizar un análisis preliminar de las tarifas basado en una selección de clientes relativamente pequeña. Tendrás los datos de 500 clientes de Megaline: quiénes son los clientes, de dónde son, qué tarifa usan, así como la cantidad de llamadas que hicieron y los mensajes de texto que enviaron en 2018. Tu trabajo es analizar el comportamiento de los clientes y determinar qué tarifa de prepago genera más ingresos.

[Te proporcionamos algunos comentarios para orientarte mientras completas este proyecto. Pero debes asegurarte de eliminar todos los comentarios entre corchetes antes de entregar tu proyecto.]

[Antes de sumergirte en el análisis de datos, explica por tu propia cuenta el propósito del proyecto y las acciones que planeas realizar.]

[Ten en cuenta que estudiar, modificar y analizar datos es un proceso iterativo. Es normal volver a los pasos anteriores y corregirlos/ampliarlos para permitir nuevos pasos.]

## Inicialización
"""

# Cargar todas las librerías
import pandas as pd
import numpy as np
import math
from math import factorial
from matplotlib import pyplot as plt

"""## Cargar datos"""

# Carga los archivos de datos en diferentes DataFrames
calls_df = pd.read_csv("/datasets/megaline_calls.csv")
internet_df = pd.read_csv("/datasets/megaline_internet.csv")
messages_df = pd.read_csv("/datasets/megaline_messages.csv")
plans_df = pd.read_csv("/datasets/megaline_plans.csv")
users_df = pd.read_csv("/datasets/megaline_users.csv")

"""## Preparar los datos

[Los datos para este proyecto se dividen en varias tablas. Explora cada una para tener una comprensión inicial de los datos. Si es necesario, haz las correcciones requeridas en cada tabla.]

## Tarifas
"""

# Imprime la información general/resumida sobre el DataFrame de las tarifas
plans_df.info()

# Imprime una muestra de los datos para las tarifas
print(plans_df)

"""[Describe lo que ves y observas en la información general y en la muestra de datos impresa para el precio de datos anterior. ¿Hay algún problema (tipos de datos no adecuados, datos ausentes, etc.) que pudieran necesitar investigación y cambios adicionales? ¿Cómo se puede arreglar?]

## Corregir datos

[Corrige los problemas obvios con los datos basándote en las observaciones iniciales.]

Se convierte usd_monthly_pay a float, ya que es un numero financiero que debe siempre incluir centavos.
"""

plans_df["usd_monthly_pay"] = plans_df["usd_monthly_pay"].astype(float)

"""## Enriquecer los datos

[Agrega factores adicionales a los datos si crees que pudieran ser útiles.]

Se agrega la columna gb_per_month_included esto para transformar el numero de mb incluidos a un numero en concreto simplificado
"""

plans_df["gb_per_month_included"] = plans_df["mb_per_month_included"]/1024

"""## Usuarios/as"""

# Imprime la información general/resumida sobre el DataFrame de usuarios
users_df.info()

# Imprime una muestra de datos para usuarios
users_df.sample(5)

"""[Describe lo que ves y observas en la información general y en la muestra de datos impresa para el precio de datos anterior. ¿Hay algún problema (tipos de datos no adecuados, datos ausentes, etc.) que pudieran necesitar investigación y cambios adicionales? ¿Cómo se puede arreglar?]

### Corregir los datos

[Corrige los problemas obvios con los datos basándote en las observaciones iniciales.]
"""

#Se modifica reg_date y churn_date a fechas para poder filtrar de manera correcta, tambien se modifica user_id a object
users_df["reg_date"] = pd.to_datetime(users_df["reg_date"], format= "%Y-%m-%d")
users_df["churn_date"] = pd.to_datetime(users_df["churn_date"], format= "%Y-%m-%d")
users_df["user_id"] = users_df["user_id"].astype("object")

#Eliminamos las filas first_name y last_name ya que no son importantes para nuestro dataset.
users_df = users_df.drop(labels=["first_name","last_name"], axis="columns")
users_df.info()

"""### Enriquecer los datos

[Agrega factores adicionales a los datos si crees que pudieran ser útiles.]
"""

users_df["reg_month"] = users_df["reg_date"].dt.month
print(users_df.sample(15))

"""## Llamadas"""

# Imprime la información general/resumida sobre el DataFrame de las llamadas
calls_df.info()

# Imprime una muestra de datos para las llamadas
calls_df.sample(15)

"""[Describe lo que ves y observas en la información general y en la muestra de datos impresa para el precio de datos anterior. ¿Hay algún problema (tipos de datos no adecuados, datos ausentes, etc.) que pudieran necesitar investigación y cambios adicionales? ¿Cómo se puede arreglar?]

### Corregir los datos

[Corrige los problemas obvios con los datos basándote en las observaciones iniciales.]
"""

#User_id se modifica a object para hacer match con los demas DFs
calls_df["user_id"] = calls_df["user_id"].astype("object")

#call_date se modifica a datetime para hcer match con el tipo de valores que contiene
calls_df["call_date"] = pd.to_datetime(calls_df["call_date"],format= "%Y-%m-%d")

"""### Enriquecer los datos

Se agrego el mes de la llamadas y ademas se redondearon los numero de las llamadas, ya que el plan consta que al pasar un segundo adicional se cobra el minnuto entero.
"""

calls_df["month"] = calls_df["call_date"].dt.month
calls_df.sample(15)

#round up the numbers, excedent from plan and additional
calls_df["duration"] = calls_df["duration"].apply(math.ceil)

#tarifa adicional

"""## Mensajes"""

# Imprime la información general/resumida sobre el DataFrame de los mensajes
messages_df.info()

# Imprime una muestra de datos para los mensajes
messages_df.sample(15)

"""[Describe lo que ves y observas en la información general y en la muestra de datos impresa para el precio de datos anterior. ¿Hay algún problema (tipos de datos no adecuados, datos ausentes, etc.) que pudieran necesitar investigación y cambios adicionales? ¿Cómo se puede arreglar?]

### Corregir los datos

[Corrige los problemas obvios con los datos basándote en las observaciones iniciales.]
"""

#User_id se modifica a object para hacer match con los demas DFs
messages_df["user_id"] = messages_df["user_id"].astype("object")

#message_date se modifica a datetime para hcer match con el tipo de valores que contiene
messages_df["message_date"] = pd.to_datetime(messages_df["message_date"],format= "%Y-%m-%d")

messages_df.info()

"""### Enriquecer los datos

[Agrega factores adicionales a los datos si crees que pudieran ser útiles.]
"""

messages_df["month"] = messages_df["message_date"].dt.month

"""## Internet"""

# Imprime la información general/resumida sobre el DataFrame de internet
internet_df.info()

# Imprime una muestra de datos para el tráfico de internet
internet_df.sample(15)

"""[Describe lo que ves y observas en la información general y en la muestra de datos impresa para el precio de datos anterior. ¿Hay algún problema (tipos de datos no adecuados, datos ausentes, etc.) que pudieran necesitar investigación y cambios adicionales? ¿Cómo se puede arreglar?]

### Corregir los datos

[Corrige los problemas obvios con los datos basándote en las observaciones iniciales.]
"""

#User_id se modifica a object para hacer match con los demas DFs
internet_df["user_id"] = internet_df["user_id"].astype("object")

#session_date se modifica a datetime para hcer match con el tipo de valores que contiene
internet_df["session_date"] = pd.to_datetime(internet_df["session_date"],format= "%Y-%m-%d")

internet_df.info()

"""### Enriquecer los datos

Se redondea el numero de mb ya que el plan al exceder un mega adicional se cobra el gb completo
"""

internet_df["month"] = internet_df["session_date"].dt.month

internet_df["mb_used"] = internet_df["mb_used"].apply(math.ceil)
internet_df.sample(15)

"""## Estudiar las condiciones de las tarifas

[Es sumamente importante entender cómo funcionan las tarifas, cómo se les cobra a los usuarios en función de su plan de suscripción. Así que te sugerimos imprimir la información de la tarifa para ver una vez más sus condiciones.]
"""

# Imprime las condiciones de la tarifa y asegúrate de que te quedan claras
print(plans_df)

messages_df.sample(15)

"""## Agregar datos por usuario

[Ahora que los datos están limpios, agrega los datos por usuario y por periodo para que solo haya un registro por usuario y por periodo. Esto facilitará mucho el análisis posterior.]
"""

# Calcula el número de llamadas hechas por cada usuario al mes. Guarda el resultado.


monthly_calls = calls_df.groupby(["user_id","month"])["duration"].count().reset_index()
monthly_calls = monthly_calls.rename(columns={"duration":"call_count"})
print(monthly_calls)

# Calcula la cantidad de minutos usados por cada usuario al mes. Guarda el resultado.
calls_duration_monthly = calls_df.groupby(["user_id","month"])["duration"].sum().reset_index()
print(calls_duration_monthly)

# Calcula el número de mensajes enviados por cada usuario al mes. Guarda el resultado.
messages_df.sample(10)
monthly_messages = messages_df.groupby(["user_id","month"])["id"].count().reset_index()
monthly_messages = monthly_messages.rename(columns={"id":"message_count"})
print(monthly_messages)

# Calcula el volumen del tráfico de Internet usado por cada usuario al mes. Guarda el resultado.
internet_df.sample(10)
monthly_data_usage = internet_df.groupby(["user_id","month"])["mb_used"].sum().reset_index()
print(monthly_data_usage)

"""[Junta los datos agregados en un DataFrame para que haya un registro que represente lo que consumió un usuario único en un mes determinado.]"""

# Fusiona los datos de llamadas, minutos, mensajes e Internet con base en user_id y month

combined_data = monthly_calls.merge(calls_duration_monthly, on=["user_id","month"], how="inner")
combined_data = combined_data.merge(monthly_messages, on=["user_id","month"], how="inner")
combined_data = combined_data.merge(monthly_data_usage, on=["user_id","month"], how="inner")
users_plan_df = users_df[["user_id","plan","city"]]
combined_data = combined_data.merge(users_plan_df,on="user_id")
print(combined_data)

print(users_df.sample(5))

# Añade la información de la tarifa
combined_data = combined_data.merge(plans_df,left_on="plan",right_on="plan_name",how="left")
print(combined_data)

"""[Calcula los ingresos mensuales por usuario (resta el límite del paquete gratuito del número total de llamadas, mensajes de texto y datos; multiplica el resultado por el valor del plan de llamadas; añade la tarifa mensual en función del plan de llamadas). Nota: Dadas las condiciones del plan, ¡esto podría no ser tan trivial como un par de líneas! Así que no pasa nada si dedicas algo de tiempo a ello.]"""

# Calcula el ingreso mensual para cada usuario

#Calcula los minutos extras
def minutes_surplus(row):
    if row['duration'] > row['minutes_included']:
        return row['duration'] - row['minutes_included']
    else:
        return 0

combined_data["minutes_surplus"] = combined_data.apply(minutes_surplus, axis=1)

#Calcula mensajes extras
def messages_surplus(row):
    if row['message_count'] > row['messages_included']:
        return row['message_count'] - row['messages_included']
    else:
        return 0

combined_data["messages_surplus"] = combined_data.apply(messages_surplus, axis=1)

#calcula mb extras
def mb_surplus(row):
    if row['mb_used'] > row['mb_per_month_included']:
        return (row['mb_used'] - row['mb_per_month_included'])/1024
    else:
        return 0

combined_data["mb_surplus"] = combined_data.apply(mb_surplus, axis=1)
#redondear al siguiente numero
combined_data["mb_surplus"] = combined_data["mb_surplus"].apply(math.ceil)

print(combined_data.sample())

#calcula costo adicional del usuario por mes


def additional_cost(row):
    return (row["minutes_surplus"]*row["usd_per_minute"])+(row["messages_surplus"]*row["usd_per_message"])+(row["mb_surplus"]*row["usd_per_gb"])

combined_data["additional_cost"] = combined_data.apply(additional_cost, axis=1)

combined_data["plan"].nunique()

print(combined_data.sample(25))

"""## Estudia el comportamiento de usuario

[Calcula algunas estadísticas descriptivas para los datos agregados y fusionados que nos sean útiles y que muestren un panorama general captado por los datos. Dibuja gráficos útiles para facilitar la comprensión. Dado que la tarea principal es comparar las tarifas y decidir cuál es más rentable, las estadísticas y gráficas deben calcularse por tarifa.]

[En los comentarios hallarás pistas relevantes para las llamadas, pero no las hay para los mensajes e Internet. Sin embargo, el principio del estudio estadístico que se aplica para ellos es el mismo que para las llamadas.]

### Llamadas
"""

# Compara la duración promedio de llamadas por cada plan y por cada mes. Traza un gráfico de barras para visualizarla.


mean_call_minutes = combined_data.groupby(["month","plan"])["duration"].mean().unstack()
print(mean_call_minutes)
mean_call_minutes.plot(kind="bar")

calls_df.sample(5)

"""[Calcula la media y la variable de la duración de las llamadas para averiguar si los usuarios de los distintos planes se comportan de forma diferente al realizar sus llamadas.]"""



# Calcula la media y la varianza de la duración mensual de llamadas.

#Medias
surf_plan = combined_data[combined_data["plan"] == "surf"]
surf_duration_mean = surf_plan["duration"].mean()

ultimate_plan = combined_data[combined_data["plan"] == "ultimate"]
ultimate_duration_mean = ultimate_plan["duration"].mean()

print(surf_duration_mean)
print(ultimate_duration_mean)

#Var Surf
var_surf_minutes = np.var(surf_plan["duration"])

#Var Ultimate
var_ultimate_minutes = np.var(ultimate_plan["duration"])

print(var_surf_minutes)
print(var_ultimate_minutes)
surf_plan.describe()

# Traza un diagrama de caja para visualizar la distribución de la duración mensual de llamadas
import seaborn as sns


sns.boxplot(surf_plan["duration"])

sns.boxplot(ultimate_plan["duration"])

"""La diferencia de medias entre un plan y otro no es muy distante sin embargo, algo que tambien caracteriza a los dos es la cantidad de valores Outliers que se encuentran en el data set, estos valores podrian ser eliminados ya que no representan algo significativo en sus cajas, tambien las diferencias no son tan amplias.

Algo que diferencia es que el rango intercuartil es mas grande para los usuarios de Surf

### Mensajes
"""

# Comprara el número de mensajes que tienden a enviar cada mes los usuarios de cada plan

messages_count = combined_data.groupby(["month","plan"])["message_count"].sum().unstack()
messages_count.plot(kind="bar")
print(messages_count)

# Calcula la media y la varianza de la duración mensual de mensajes


# Mean Surf Messages
mean_surf_messages = messages_count["surf"].mean()

# Mean Ultimate Messages
mean_ultimate_messages = messages_count["ultimate"].mean()

# Variance Surf Messages
var_surf_messages = np.var(messages_count["surf"])

# Variance Ultimate Messages
var_ultimate_messages = np.var(messages_count["ultimate"])

print(mean_surf_messages)
print(mean_ultimate_messages)
print(var_surf_messages)
print(var_ultimate_messages)

sns.boxplot(messages_count["ultimate"])

sns.boxplot(messages_count["surf"])

"""Las medias de cada uno de los planes son muy distintas los usuarios surf tiene una media de casi 50% mas que los usuarios de ultimate esto se refleja en los diagramas de caja, donde la caja de surf su rango intercuartil se encuentra de entre 500 y 6000 y para ultimate esta entre 500 y 3500

### Internet
"""

# Compara la cantidad de tráfico de Internet consumido por usuarios por plan

internet_count = combined_data.groupby(["month","plan"])["additional_cost"].sum().unstack()
internet_count.plot(kind="bar")
print(internet_count)

# Calcula la media y la varianza de los mb adicionales

# Mean Surf internet
mean_surf_internet = internet_count["surf"].mean()

# Mean Ultimate internet
mean_ultimate_internet = internet_count["ultimate"].mean()

# Variance Surf internet
var_surf_internet = np.var(internet_count["surf"])

# Variance Ultimate internet
var_ultimate_internet = np.var(internet_count["ultimate"])

print(mean_surf_internet)
print(mean_ultimate_internet)
print(var_surf_internet)
print(var_ultimate_internet)

sns.boxplot(internet_count["surf"])

sns.boxplot(internet_count["ultimate"])

"""Las diferencias son abismales, en conclusion los usuarios de Surf utilizan el servicio de internet muchisimo mas que los usuarios ultimate

## Ingreso

[Del mismo modo que has estudiado el comportamiento de los usuarios, describe estadísticamente los ingresos de los planes.]
"""

# Compara la cantidad de ingreso adicional consumido por usuarios por plan
income_surplus_count = combined_data.groupby(["month","plan"])["additional_cost"].sum().unstack()
income_surplus_count.plot(kind="bar")
print(income_surplus_count)

# Calcula la media y la varianza del ingreso adicional
# Mean Surf income_surplus
mean_surf_income_surplus = income_surplus_count["surf"].mean()

# Mean Ultimate income_surplus
mean_ultimate_income_surplus = income_surplus_count["ultimate"].mean()

# Variance Surf income_surplus
var_surf_income_surplus = np.var(income_surplus_count["surf"])

# Variance Ultimate income_surplus
var_ultimate_income_surplus = np.var(income_surplus_count["ultimate"])

print(mean_surf_income_surplus)
print(mean_ultimate_income_surplus)
print(var_surf_income_surplus)
print(var_ultimate_income_surplus)

sns.boxplot(income_surplus_count["ultimate"])

sns.boxplot(income_surplus_count["surf"])

"""Los usuarios surf, debido a como hemos notado que utilizan todo de manera mas amplia acaban gastando en costos adicionales muchisimo mas en promedio que los usuarios ultimate, para la empresa convendria mas promover el paquete Surf ya que los costos adicionales sobrepasan al costo en general del paquete ultimate

## Prueba las hipótesis estadísticas

[Prueba la hipótesis de que son diferentes los ingresos promedio procedentes de los usuarios de los planes de llamada Ultimate y Surf.]

[Elabora las hipótesis nula y alternativa, escoge la prueba estadística, determina el valor alfa.]
"""

# Prueba las hipótesis
#mean_surf_income_surplus
#mean_ultimate_income_surplus

from scipy import stats as st

alpha = 0.05

results = st.ttest_ind(income_surplus_count["surf"],income_surplus_count["ultimate"])

print("valor p:", results.pvalue)

if results.pvalue < alpha:
    print("Rechazamos la hipotesis nula")
else:
    print("No podemos rechazar la hipotesis nula")

"""[Prueba la hipótesis de que el ingreso promedio de los usuarios del área NY-NJ es diferente al de los usuarios de otras regiones.]

[Elabora las hipótesis nula y alternativa, escoge la prueba estadística, determina el valor alfa.]
"""

print(combined_data.sample(5))

# Prueba las hipótesis New York-Newark-Jersey City, NY-NJ-PA MSA
ny_data = combined_data[combined_data["city"] == "New York-Newark-Jersey City, NY-NJ-PA MSA"]
other_states = combined_data[combined_data["city"] != "New York-Newark-Jersey City, NY-NJ-PA MSA"]

alpha = 0.05

results_ny = st.ttest_ind(ny_data["additional_cost"],other_states["additional_cost"])


print("valor p:", results.pvalue)

if results.pvalue > alpha:
    print("Rechazamos la hipotesis nula")
else:
    print("No podemos rechazar la hipotesis nula")

"""## Conclusión general

[En esta sección final, enumera tus conclusiones importantes. Asegúrate de que estas abarquen todas las decisiones (suposiciones) importantes que adoptaste y que determinaron la forma elegida para procesar y analizar los datos.]
"""